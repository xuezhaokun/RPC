<!DOCTYPE HTML>
<!-- 
 **********************************************************

             TUFTS COMP 150-IDS HOMEWORK ASSIGNMENT

        Fill in your name, e-mail and answers to questions
        in the sections provided below.

          All questions are marked up: <li class="q">
          All answers are marked up:   <li class="a">


     PLEASE DO NOT MODIFY ANY THING OTHER THAN THE 
     NAME, E-MAIL, AND ANSWER FIELDS (you may also add
     css declarations in the <head> if you need them,
     but usually you won't.

 **********************************************************
 -->


<html>
<head>
<meta charset="utf-8"> 
<title>Tufts COMP 150-IDS Assignment &#8212; Remote Procedure Call Project Report</title>
<link rel="stylesheet" type="text/css" href="http://www.cs.tufts.edu/comp/150IDS/style/homework.css" />
</head>

<body class="homework">


<!-- ******************************************************
	   YOU MUST FILL IN YOUR NAME, UTLN AND EMAIL BELOW!!
         (You may copy this from an earlier assignment
                         if you like)

     ****************************************************** -->


<div class="student">
<p>
<span class="label">Student1 name: </span>
Zhaokun Xue
<br>

<span class="label">UTLN: </span>
zhaokun 
<br>

<span class="label">E-mail: </span>
<!-- DON'T FORGET UP UPDATE THE MAILTO: URI BELOW ALONG WITH
     YOUR EMAIL IN THE ANCHOR.  IT SHOULD LOOK LIKE:
 <a href="mailto:lady.gaga@cs.tufts.edu">lady.gaga@cs.tufts.edu</a>
--> 

<a href="mailto:Zhaokun.Xue@tufts.edu">Zhaokun.Xue@tufts.edu</a>


<br>
</p>
</div>




<div class="UpperLeftHeader">
<p>Tufts COMP 150-IDS (Spring 2016):
<br>
Internet-scale Distributed Systems</p>
</div>


<!-- - - - - - - - - - - - - - - - - - - - - - - -
		HOMEWORK TITLE
  - -  - - - - - - - - - - - - - - - - - - - - - - -->


<div class="headerdiv">
<h1>
Tufts COMP 150-IDS:<br>
RPC Project Report
</h1>
</div>

<!-- ******************************************************

              PLEASE ANSWER QUESTIONS IN THE SECTIONS
	      LABELED class="a" (for answer)

     ****************************************************** -->




<div class="main">

<h2 id="questions">Questions</h2>
<!-- - - - - - - - - - - - - - - - - - - - - - - -
		QUESTION
  - -  - - - - - - - - - - - - - - - - - - - - - - -->
<div class="qa">

<ol class="qa">
<li class="q">Did you implement an rpcgenerate program and does it handle all legal IDL files? If not, which test cases should we try in your submission  directory?</li>
<li class="a">
I implemented an rpcgenerate program, and based on my tests, I think it can handle all legal IDL files.
</li>

<li class="q">Briefly explain the protocol you use over TCP to request function calls and return the results.</li>
<li class="a">
In my program, I have two serializer files to help me handle the read and write functions over TCP. One is static, called basicTypeHandler. This is used to handle send and read functions for built-in types, i.e. string, int, float and void. The other called xxx.additionalTypeHandler is dynamically generated by my rpcgenerate program based on the given IDL file, where xxx is the basename of IDL file. This file provides helper functions for handling send and read functions for arrays and structs type defined in the IDL file.
<br />
<h4>Explain for basicTypeHandler: </h4>
<b>1. send/read string type: </b><br />
On the sender side, it sends the length of the string first, and then sends the actual content of the string.<br />
On the receiver side, it reads the length of the string first, and builds a buffer with that length. And final read the string content from sender to the buffer.
<br />
<br />
<b>2. send/read int type: </b><br />
I use "htonl" and "ntohl" to handle the read and send for int type data. The reason is explained in the following question.
<br />
<br />
<b>3. send/read float type: </b><br />
On the sender side, convert the float to a char* buffer with size 32, because the size of float is 32. Then send the char* to receiver. <br />
On the receiver side, initialize a char* buffer with size 32, and fill the buffer with the stuff read from server.
<br />
<br />
<b>4. send/read void type: </b><br />
Just send/read a string "void" to indicate it is a void type.
<br />
<br />
5. send/read function name <br />
I borrow the read function name from our start code provided by Noah. And use a simple write function to send the function name.
<br />
<br />
<h4>Explain for xxx.additionalTypeHandler: </h4>
Based on the given IDL file, my rpcgenerate program will build this file for handling arrays and structs defined in the IDL file. Since all the arrays and structs are made from the basic built-in types, I build the "send/read array" and "send/read struct" just upon "send/read built-in type". <br />
<b>1. send/read array: </b><br />
On the sender side, first find the basic type of the given array's element and build the for loop for iterating each element based on the array's bound. Then call the send function for that type to send the elements one by one in order.Since we use TCP, these elements will be guaranteed to be delivered in order.<br />
On the receiver side, its read function takes an additional parameter, which is an array with the same construct as the array it is going to read. Since we cannot return an array properly, the only way to solve it is to fill the array's value into a given array parameter. Then it just needs to build the for loop for reading the coming values one by one in order. Since we use TCP, every elemnet is received in order without any loss data. This can guarantee us to have the same content.
<br />
<br />
<b>2. send/read struct: </b><br />
Just loop once of all members of the struct, and send/read each member based on its type. If the member is a basic type, just call read/send function in basicTypeHandler. If it is an array or struct, just use the array or struct handler in addtionalTypeHandler. Since we use TCP, every member will be delivered and read in order.
<br />
<br />
<h4>Explain for Proxy and Stub: </h4>
Since we use TCP, everything will be guaranteed to be delivered in order. Therefore, on proxy side, we just need to make sure send everything in the order we want, and on stub side, read everything in the same order.<br />
<b>From proxy side</b>, I send each function request call in the following order:
<br />
1. send the function name to stub <br />
2. iterate function's arguments and send them one by one in order <br />
3. based on the function's return type, read and return the result from stub <br />
<br />
<b>From stub side</b>, iterate each function and build each procedure in the following order: <br />
1. Read the function name from proxy <br />
2. Iterate function's arguments and read them one by one in order. <br />
3. Based on the function name, invoke the actual function call. <br />
4. Send the result from actual function call back to proxy<br />
</li>

<li class="q">Did you get help from anyone other than your teammate? If "yes", then briefly explain who helped you and how.</li>
<li class="a">
I got some help and inspired from a discussion about sending and reading int over TCP on stackoverflow. The way I used to do was to convert int to a fixed 32 length char* and then send it over the Internet. But when I tested my program, I found when I sent a large number of integers in row, the received data could be messed up. I guess it might be caused by the read buffer length. I think I also had similar problem in my FileCopy project. My FileCopy project cannot handler small size files with fixed read buffer length 512. Then I used the solution "htonl and ntohl" from stackoverflow. This idea also inspired me to come up with the solution for send/read string type. Instead of converting the string to char*, sending it directly and reading it to a fixed 256 length buffer, I send the length of the string first, and build the read buffer with this length on the receiver side. Finally, read the char* to this buffer. The other thing I borrowed from stackoverflow is the helper function for splitting a c++ string. Since I had a bad experience with "strtok" in FileCopy project. This time I use the helper "split" function to split a c++ string directly into a c++ vector. I also got help on building my Makefile from Noah.
</li>


<li class="q">(optional) Do you have any other comments on this assignment (e.g. was it worthwhile, what did you learn from it, do you have suggestions for improvment if the course is offered again)?</li>
<li class="a">
When we discussed about this project in class, the solution for handling arrays and structs I came up with was to build one big packet which contains all the stuff in the struct or array, and send it over the Internet. One the other side, we unpacket it and insert each part to the corresponding place. When I used this method to build my first version of rpcgenerate program, I found this was really a bad idea. It was really annoying to build this big packet and the unpacket work was horrible. And if we have a really huge array or struct, things would become worse. At that time, I realized in my design I just used the reliable property of TCP. I did not design anything related to the ordered property of TCP. After realizing the ordered property of TCP, I designed my current solution, send/read every smallest component in order, since we can control this over TCP. The coding part of this project was not that hard, but we really needed to spend a lot of time designning the protocol. Once we were on the right track, things would become easier. 
</li>

</ol>

<!-- * * * * * * * * * * * * * * * * * * * * * -->
<!--         ADDITIONAL INFORMATION            -->
<!-- * * * * * * * * * * * * * * * * * * * * * -->

<h2 id="reportbody">ADDITIONAL iNFORMATION</h2>

<h3>How to read my Grading Logs: <h3/>
<h4>Client Grading Logs</h4>
<table border="1" style="table-layout:fixed; ">
  <thead>
    <tr>
      <th>
          EVENTS
      </th>
      <th>
          LOGS
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        Proxy starts function request
      </td>
      <td>
        PROXY: start sending request for function, "function name"
      </td>
    </tr>
    <tr>
      <td>
        Proxy iterates and sends function arguments
      </td>
      <td>
        PROXY: send function argument, "argument name"
      </td>
    </tr>
    <tr>
      <td>
        Proxy read the result from stub
      </td>
      <td>
        PROXY: read result from stub for function, "function name"
      </td>
    </tr>
  </tbody>
</table>

<h4>Server Grading Logs</h4>
<table border="1" style="table-layout:fixed; ">
  <thead>
    <tr>
      <th>
          EVENTS
      </th>
      <th>
          LOGS
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        Stub starts receiving function request
      </td>
      <td>
        STUB: start receiving request for function, "function name"
      </td>
    </tr>
    <tr>
      <td>
        Stub starts reading each function argument 
      </td>
      <td>
         STUB: read argument, "argument name"
      </td>
    </tr>
    <tr>
      <td>
        Stub invokes actual function call
      </td>
      <td>
        STUB: make actual function call for function, "function name"
      </td>
    </tr>
    <tr>
      <td>
        Stub sends back result
      </td>
      <td>
         STUB: send result back to proxy.
      </td>
    </tr>
    <tr>
      <td>
        Stub handles bad function call
      </td>
      <td>
        STUB: Bad Request Call!!!
      </td>
    </tr>
  </tbody>
</table>
</div>
</div>
</body>
</html>